<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="数据结构与算法（java）数据结构与算法概述程序&#x3D;数据结构+算法 数据结构定义  把数据元素按照一定的关系组织起来的集合，用来组织和存储数据  分类 逻辑结构 逻辑结构是从具体问题中抽象出来的模型，是抽象意义上的结构，按照对象中数据元素之间的相互关系分类 可分为  集合结构：集合中元素除了属于同一个集合以外，不再有其他的任何关系   线性结构：线性结构中的元素之间存在一对一的关系   树">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2022/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="数据结构与算法（java）数据结构与算法概述程序&#x3D;数据结构+算法 数据结构定义  把数据元素按照一定的关系组织起来的集合，用来组织和存储数据  分类 逻辑结构 逻辑结构是从具体问题中抽象出来的模型，是抽象意义上的结构，按照对象中数据元素之间的相互关系分类 可分为  集合结构：集合中元素除了属于同一个集合以外，不再有其他的任何关系   线性结构：线性结构中的元素之间存在一对一的关系   树">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:/Users/SFAG/AppData/Roaming/Typora/typora-user-images/image-20211203174213957.png">
<meta property="og:image" content="c:/Users/SFAG/AppData/Roaming/Typora/typora-user-images/image-20211203174544793.png">
<meta property="og:image" content="c:/Users/SFAG/AppData/Roaming/Typora/typora-user-images/image-20211203174554010.png">
<meta property="og:image" content="c:/Users/SFAG/AppData/Roaming/Typora/typora-user-images/image-20211203174618818.png">
<meta property="og:image" content="c:/Users/SFAG/AppData/Roaming/Typora/typora-user-images/image-20211205150113199.png">
<meta property="og:image" content="c:/Users/SFAG/AppData/Roaming/Typora/typora-user-images/image-20211205150202489.png">
<meta property="og:image" content="c:/Users/SFAG/AppData/Roaming/Typora/typora-user-images/image-20211205150711149.png">
<meta property="og:image" content="c:/Users/SFAG/AppData/Roaming/Typora/typora-user-images/image-20211206104144547.png">
<meta property="og:image" content="c:/Users/SFAG/AppData/Roaming/Typora/typora-user-images/image-20211206104427923.png">
<meta property="og:image" content="c:/Users/SFAG/AppData/Roaming/Typora/typora-user-images/image-20211212150446144.png">
<meta property="article:published_time" content="2022-06-26T14:10:59.816Z">
<meta property="article:modified_time" content="2021-12-19T06:17:40.724Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/SFAG/AppData/Roaming/Typora/typora-user-images/image-20211203174213957.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-数据结构与算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2022-06-26T14:10:59.816Z" itemprop="datePublished">2022-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据结构与算法（java）"><a href="#数据结构与算法（java）" class="headerlink" title="数据结构与算法（java）"></a>数据结构与算法（java）</h1><h3 id="数据结构与算法概述"><a href="#数据结构与算法概述" class="headerlink" title="数据结构与算法概述"></a>数据结构与算法概述</h3><p>程序&#x3D;数据结构+算法</p>
<h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p>定义</p>
<ul>
<li>把数据元素按照一定的关系组织起来的集合，用来组织和存储数据</li>
</ul>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ol>
<li><p><strong>逻辑结构</strong></p>
<p>逻辑结构是从具体问题中抽象出来的模型，是抽象意义上的结构，按照对象中数据元素之间的相互关系分类</p>
<p>可分为</p>
<ul>
<li><p><strong>集合结构</strong>：集合中元素除了属于同一个集合以外，不再有其他的任何关系</p>
<p><img src="C:\Users\SFAG\AppData\Roaming\Typora\typora-user-images\image-20211203174213957.png" alt="image-20211203174213957"></p>
</li>
<li><p><strong>线性结构</strong>：线性结构中的元素之间存在一对一的关系</p>
<p><img src="C:\Users\SFAG\AppData\Roaming\Typora\typora-user-images\image-20211203174544793.png" alt="image-20211203174544793"></p>
</li>
<li><p><strong>树形结构</strong>：树形结构中的元素存在一对多的关系</p>
<p><img src="C:\Users\SFAG\AppData\Roaming\Typora\typora-user-images\image-20211203174554010.png"></p>
</li>
<li><p><strong>图形结构</strong>：图形结构中的元素存在多对多的关系</p>
<p><img src="C:\Users\SFAG\AppData\Roaming\Typora\typora-user-images\image-20211203174618818.png" alt="image-20211203174618818"></p>
</li>
</ul>
</li>
<li><p><strong>物理结构</strong></p>
<p>定义：是逻辑结构在计算机中真正的表现方式（又称为映像），也可以叫做存储结构，常见的存储结构有顺序存储结构、链式存储结构</p>
<ul>
<li><p>顺序存储结构</p>
<p>​	把数据元素存储在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的，比如常用的数组就是顺序存储结构</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
</table>
<p>缺点：对添加或删除操作不太方便，此时就需要链式存储结构</p>
</li>
<li><p>链式存储结构</p>
<p>​		是把数据元素放在任意的存储单元里，这组数据可以是连续的也可以是不连续的，此时，数据元素之间并不能反映元素间的逻辑关系，因此在链式存储结构中引进了一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据的位置</p>
</li>
</ul>
</li>
</ol>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>​		官方解释：算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法解决问题的策略机制。也就是所，能够对一定规范的输入，在一定时间内获得所要求的结果</p>
<p>​		算法就是根据一定的条件，对已有的数据进行计算，得到需要的结果</p>
<ul>
<li>花费最少的时间完成需求</li>
<li>占用最少的内存空间完成需求</li>
</ul>
<h5 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h5><ul>
<li><p>算法函数中的常数可以忽略</p>
</li>
<li><p>算法函数中最高次幂的常数因子可以忽略</p>
</li>
<li><p>随着输入规模的增大，与最高次项的相乘的常数可以忽略</p>
</li>
<li><p>算法函数中最高次幂越小，算法效率越高</p>
</li>
</ul>
<h5 id="大O记法"><a href="#大O记法" class="headerlink" title="大O记法"></a>大O记法</h5><p>规则：</p>
<ol>
<li><p>用常数1取代运行次数中所有的加法常数</p>
</li>
<li><p>在修改后的运行次数中，只保留高阶项</p>
</li>
<li><p>如果最高阶项存在，且常数因子不为1，则去除与这个项相乘的常数</p>
<p>例：</p>
<ul>
<li>算法一：3—&gt;O(1)</li>
<li>算法二：n+3—&gt;O(n)</li>
<li>算法三：n<del>2+2—&gt;O(n</del>2)</li>
</ul>
</li>
</ol>
<h5 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h5><p>描述算法对内存的占用</p>
<p>java中常见的内存占用</p>
<ul>
<li><p>基本数据类型内存占用情况</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">内存占用字节</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h5 id="comparable接口"><a href="#comparable接口" class="headerlink" title="comparable接口"></a>comparable接口</h5><p><img src="C:\Users\SFAG\AppData\Roaming\Typora\typora-user-images\image-20211205150113199.png" alt="image-20211205150113199"></p>
<p><img src="C:\Users\SFAG\AppData\Roaming\Typora\typora-user-images\image-20211205150202489.png" alt="image-20211205150202489"></p>
<h4 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h4><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><p>排序原理：</p>
<ul>
<li><p>比较相邻的两个元素，如果前一个元素比后一个元素大，就交换这两个元素的位置</p>
</li>
<li><p>对每一对相邻的元素做同样 的工作，从开始第一对元素到结尾的最后一对元素，最终最后位置的元素就是最大值</p>
<p><img src="C:\Users\SFAG\AppData\Roaming\Typora\typora-user-images\image-20211205150711149.png" alt="image-20211205150711149"></p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sort1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="comment">//i为数组长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= a.length-<span class="number">1</span>;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//j为元素对应的索引</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="comment">//比较索引j和索引j+1处的元素</span></span><br><span class="line">                <span class="keyword">if</span>(great(a[j],a[j+<span class="number">1</span>]))&#123;</span><br><span class="line">                    exch(a,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">great</span><span class="params">(Comparable s , Comparable t)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.compareTo(t)&gt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数组中元素位置交换</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a,<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp=a[i];</span><br><span class="line">        a[i]=a[j];</span><br><span class="line">        a[j]=temp;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sfag.algorithm.sort.sort1;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试冒泡排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sort1Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer [] a = &#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        sort1.sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>时间复杂度：</p>
<p>元素比较的次数：(n-1)+(n-2)+(n-3)+……+3+2+1&#x3D;((n-1)+1)*(n-1)&#x2F;2&#x3D;n∧2&#x2F;2-n&#x2F;2</p>
<p>元素交换位置的次数：(n-1)+(n-2)+(n-3)+……+3+2+1&#x3D;((n-1)+1)*(n-1)&#x2F;2&#x3D;n∧2&#x2F;2-n&#x2F;2</p>
<p>时间复杂度：n∧2&#x2F;2-n&#x2F;2+n∧2&#x2F;2-n&#x2F;2&#x3D;O(n∧2)</p>
</li>
</ul>
<h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><p>原理：</p>
<ul>
<li><p>每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次比较，如果当前索引的值大于其他某个索引处的值，则假定其他某个索引处的值为最小值，继续比下午，到最后可以找到最小值所在的索引</p>
</li>
<li><p>交换第一个索引处和最小值所在索引处的值</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="comment">//从索引0开始，默认最小值索引为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=a.length-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">                <span class="comment">//如果索引为minIndex处的值大于索引为j处的值，则让最小值的索引变为j</span></span><br><span class="line">                <span class="keyword">if</span>(great(a[minIndex],a[j]))&#123;</span><br><span class="line">                    minIndex=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换元素位置</span></span><br><span class="line">            exch(a,i,minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">great</span><span class="params">(Comparable s , Comparable t)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.compareTo(t)&gt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数组中元素位置交换</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a,<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp=a[i];</span><br><span class="line">        a[i]=a[j];</span><br><span class="line">        a[j]=temp;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>时间复杂度：</p>
<ul>
<li>数据比较次数：(n-1)+(n-2)+(n-3)+……+3+2+1&#x3D;((n-1)+1)*(n-1)&#x2F;2&#x3D;n∧2&#x2F;2-n&#x2F;2</li>
<li>位置交换次数：n-1</li>
<li>时间复杂度：n∧2&#x2F;2-n&#x2F;2+(n-1)&#x3D;O(n∧2)</li>
</ul>
</li>
</ul>
<h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><ul>
<li><p>实现原理：</p>
<ul>
<li>把所有元素分为两部分：已经排序的和未排序的</li>
<li>找到未排序的组中的第一个元素，向已经排序的元素组中插入</li>
<li>倒序遍历已经排序的元素，依次和待插入的元素进行比较，知道在已经排序的元素中找到小于等于待插入的元素，那么就把待插入元素放到这个元素后面，其他元素向后移动一位</li>
</ul>
</li>
<li><p>代码实现：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">InsertSort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="comment">//一开始有一个已排序的元素，从索引为1的元素开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span> ; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(method.great(a[j-<span class="number">1</span>],a[j]))&#123;</span><br><span class="line">                    method.exch(a,j-<span class="number">1</span>,j);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度分析：<ul>
<li>数据比较次数：(n-1)+(n-2)+(n-3)+……+3+2+1&#x3D;((n-1)+1)*(n-1)&#x2F;2&#x3D;n∧2&#x2F;2-n&#x2F;2</li>
<li>位置交换次数：(n-1)+(n-2)+(n-3)+……+3+2+1&#x3D;((n-1)+1)*(n-1)&#x2F;2&#x3D;n∧2&#x2F;2-n&#x2F;2</li>
<li>时间复杂度：n∧2&#x2F;2-n&#x2F;2+n∧2&#x2F;2-n&#x2F;2&#x3D;O(n∧2)</li>
</ul>
</li>
</ul>
<h4 id="复杂排序"><a href="#复杂排序" class="headerlink" title="复杂排序"></a>复杂排序</h4><h5 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h5><ul>
<li><p>排序原理</p>
<ol>
<li><p>选定一个增长量h，按照增长量h作为数据分组的依据，对数组进行分组</p>
</li>
<li><p>对分好组的每一组数据完成插入排序</p>
</li>
<li><p>减小增长量，最小为1，重复第二步操作</p>
<p><img src="C:\Users\SFAG\AppData\Roaming\Typora\typora-user-images\image-20211206104144547.png" alt="image-20211206104144547"></p>
</li>
<li><p>增长量的确认</p>
<p><img src="C:\Users\SFAG\AppData\Roaming\Typora\typora-user-images\image-20211206104427923.png" alt="image-20211206104427923"></p>
</li>
</ol>
</li>
<li><p>代码实现</p>
</li>
</ul>
<h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><p>​	归并排序是建立在归并操作上的一种有效的排序算法，算法采用分治法的一个非常经典的应用。将已经有序的子序列合并，得到完全有序的序列；即先让每个子序列有序，再使各个子序列之间有序。若将两个有序表合成一个有序表，成为二路归并</p>
<ul>
<li><p>排序原理：</p>
<ul>
<li>尽可能的一组数据拆分为两个元素数量相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数为1为止</li>
<li>将相邻的两个子组合并成一个有序的大组</li>
<li>不断的重复步骤，直到最终只有一个组为止</li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sfag.algorithm.sort;</span><br><span class="line"><span class="keyword">import</span> com.sfag.algorithm.common.method;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] assist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组a中的元素进行排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        assist = <span class="keyword">new</span> <span class="title class_">Comparable</span>[a.length];</span><br><span class="line">        <span class="type">int</span> lo=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> hi=a.length-<span class="number">1</span>;</span><br><span class="line">        sort(a,lo,hi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载Sort，对数组a中的子组进行排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> hi)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi&lt;=lo) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">        sort(a,lo,mid);</span><br><span class="line">        sort(a,mid+<span class="number">1</span>,hi);</span><br><span class="line">        merge(a,lo,mid,hi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序+归并</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(Comparable[] a, <span class="type">int</span> lo,<span class="type">int</span> mid ,<span class="type">int</span> hi)</span>&#123;</span><br><span class="line">        <span class="comment">//定义三个指针</span></span><br><span class="line">        <span class="type">int</span> i=lo;</span><br><span class="line">        <span class="type">int</span> p1=lo;</span><br><span class="line">        <span class="type">int</span> p2=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//遍历比较两个子组索引处的元素，将小的放到辅助数组的对应索引位置</span></span><br><span class="line">        <span class="keyword">while</span> (p1&lt;=mid &amp;&amp; p2&lt;=hi)&#123;</span><br><span class="line">            <span class="keyword">if</span>(method.great(a[p1],a[p2]))&#123;</span><br><span class="line">                assist[i++]=a[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果p1的指针没走完，那么顺序移动p1指针，并把对应的元素放到辅助数组对应的位置</span></span><br><span class="line">        <span class="keyword">while</span> (p1&lt;=mid)&#123;</span><br><span class="line">            assist[i++]=a[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果p2的指针没走完，那么顺序移动p1指针，并把对应的元素放到辅助数组对应的位置</span></span><br><span class="line">        <span class="keyword">while</span> (p2&lt;=hi)&#123;</span><br><span class="line">            assist[i++]=a[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将辅助数组中的元素放回原数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=lo;j&lt;=hi;j++)&#123;</span><br><span class="line">            a[j]=assist[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>时间复杂度分析：</p>
<p><img src="C:\Users\SFAG\AppData\Roaming\Typora\typora-user-images\image-20211212150446144.png" alt="image-20211212150446144"></p>
<ul>
<li>如果一个数组有八个元素，那么它将每次除以二寻找最小的子数组，共拆分log8次，值为3，所以共有三层，自上到下，第k层有2^k个数组，每个数组的长度为2^(3-k)，归并最多需要2^(3-k)次比较，因此每层比较次数为2^k*2^(3-k)&#x3D;2^3，那么是三层总共为3 *2^3</li>
<li>假设元素的个数为n，那么使用归并排序拆分的次数为log2(n)，所以共log2(n)层，则总共为log2(n)*2^(log2(n))&#x3D;log2(n) *n，即归并排序的时间复杂度为：log2(n) *n，根据大O计发：时间复杂度为n *log(n)</li>
</ul>
</li>
</ul>
<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><ul>
<li><p>排序原理：</p>
<ol>
<li>首先设定一个分界值，通过改分界值将数组分为两部分；</li>
<li>将大于或等于分界值的数据放到数组右边，小于分界值的数据放到数组的左边</li>
<li>然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右部分，童颜跟步骤2一样</li>
<li>重复上述操作，可以看出，这是一个递归定义。通过递归将左侧数据排好序后，再递归排好右侧部分的顺序，则整个数组就完成排序了</li>
</ol>
</li>
<li><p>数组切分原理：</p>
<ol>
<li>找一个基准值，用两个指针分别指向数组的头和尾</li>
<li>先从尾部向头部开始搜索一个比基准值小的元素，搜索到即停止，并记录指针的位置</li>
<li>再从同头部向尾部开始搜索一个比基准值大的元素，搜索到即停止，并记录指针的位置</li>
<li>交换左右两边指针所指元素的位置</li>
<li>重复234步骤，直到左边指针的值大于右边指针的值停止</li>
</ol>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sfag.algorithm.sort;</span><br><span class="line"><span class="keyword">import</span> com.sfag.algorithm.common.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hi</span> <span class="operator">=</span> a.length-<span class="number">1</span>;</span><br><span class="line">        sort(a,lo,hi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a,<span class="type">int</span> lo, <span class="type">int</span> hi)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo&gt;=hi)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a, lo,hi);</span><br><span class="line">        <span class="comment">//对拆分后的左边子组进行排序</span></span><br><span class="line">        sort(a, lo, p-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//对拆分后的右边子组进行排序</span></span><br><span class="line">        sort(a, p+<span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组进行分组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> hi)</span>&#123;</span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">key</span> <span class="operator">=</span> a[lo];</span><br><span class="line">        <span class="comment">//定义左指针和右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> lo;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> hi+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//切分</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//System.out.println(Arrays.toString(a));</span></span><br><span class="line">            <span class="comment">//从右往左扫描，找到一个比分界值小的，停止</span></span><br><span class="line">            <span class="keyword">while</span> (method.great(a[--right],key))&#123;</span><br><span class="line">                <span class="keyword">if</span>(right==lo)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从左往右扫描，找到一个比分界值大的，停止</span></span><br><span class="line">            <span class="keyword">while</span> (method.great(key,a[++left]))&#123;</span><br><span class="line">                <span class="keyword">if</span>(left==hi)&#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断left&gt;=rirht,如果是，说明遍历结束，停止循环，如果不是，则交换指针所指元素</span></span><br><span class="line">            <span class="keyword">if</span>(left&gt;=right)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                method.exch(a,left,right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换分界值和最后两个指针同时指向的值的位置</span></span><br><span class="line">        method.exch(a,lo,right);</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>时间复杂度分析：拆分的次数*n</p>
<p>取决于拆分的次数：</p>
<ul>
<li>最优情况：每此拆分的分界值刚好将数组等分，一共切分了logn次，则时间负责度为：nlogn</li>
<li>最坏情况：每此切分的分界值为数组中的最大值或最小值，则需要切分n次，时间复杂度为：n^2</li>
</ul>
</li>
</ul>
<h5 id="排序的稳定性分析"><a href="#排序的稳定性分析" class="headerlink" title="排序的稳定性分析"></a>排序的稳定性分析</h5><p>稳定与不稳定：数组中油若干元素，如果有两个相等的元素a和b，排序之前a在b之前，如果经过排序之后，a依旧在b前面，则说明排序算法是稳定的，否则就是不稳定的</p>
<ul>
<li>稳定的排序算法：冒泡排序、插入排序、归并排序</li>
<li>不稳定的算法：选择排序、希尔排序、快速排序</li>
</ul>
<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" data-id="cl4ve2jm5000aw0gv6wr9384e" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/06/26/%E5%B7%A5%E7%A8%8B%E9%97%B4%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2022/06/26/%E7%AC%AC%E4%B9%9D%E8%8A%82%EF%BC%9Aspringboot%E9%9B%86%E6%88%90redis%E5%8F%8A%E4%BD%BF%E7%94%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/26/RabbitMQ%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/26/redis/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/26/ody-db/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/26/Nginx/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/26/PMO%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>