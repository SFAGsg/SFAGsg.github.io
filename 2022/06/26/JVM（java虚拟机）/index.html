<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="JVM（java虚拟机）java：跨平台的语言 jvm：跨语言的平台  三种JVM Sun公司：Java HotShop BEA ：JRockit IBM：J9VM    虚拟机 概念：就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上可分为系统虚拟机（如：VMware）和程序虚拟机（JVM） java虚拟机是一台用于执行java字节码的虚拟计算机，它拥有独立的运行机制，其运">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2022/06/26/JVM%EF%BC%88java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%89/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="JVM（java虚拟机）java：跨平台的语言 jvm：跨语言的平台  三种JVM Sun公司：Java HotShop BEA ：JRockit IBM：J9VM    虚拟机 概念：就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上可分为系统虚拟机（如：VMware）和程序虚拟机（JVM） java虚拟机是一台用于执行java字节码的虚拟计算机，它拥有独立的运行机制，其运">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:/Users/SFAG/AppData/Roaming/Typora/typora-user-images/image-20211128135252574.png">
<meta property="og:image" content="c:/Users/SFAG/AppData/Roaming/Typora/typora-user-images/image-20211128135653464.png">
<meta property="og:image" content="c:/Users/SFAG/AppData/Roaming/Typora/typora-user-images/image-20211128140444203.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020121722082798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGV5YW5iYW8=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="c:/Users/SFAG/AppData/Roaming/Typora/typora-user-images/image-20211128150615195.png">
<meta property="og:image" content="c:/Users/SFAG/AppData/Roaming/Typora/typora-user-images/image-20211129222840327.png">
<meta property="og:image" content="c:/Users/SFAG/AppData/Roaming/Typora/typora-user-images/image-20211202153633679.png">
<meta property="og:image" content="c:/Users/SFAG/AppData/Roaming/Typora/typora-user-images/image-20211202163901504.png">
<meta property="og:image" content="c:/Users/SFAG/AppData/Roaming/Typora/typora-user-images/image-20211202164010355.png">
<meta property="og:image" content="c:/Users/SFAG/AppData/Roaming/Typora/typora-user-images/image-20211202164041124.png">
<meta property="article:published_time" content="2022-06-26T10:49:51.164Z">
<meta property="article:modified_time" content="2022-06-05T02:15:48.533Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/SFAG/AppData/Roaming/Typora/typora-user-images/image-20211128135252574.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-JVM（java虚拟机）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/26/JVM%EF%BC%88java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2022-06-26T10:49:51.164Z" itemprop="datePublished">2022-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JVM（java虚拟机）"><a href="#JVM（java虚拟机）" class="headerlink" title="JVM（java虚拟机）"></a>JVM（java虚拟机）</h1><p><strong>java：跨平台的语言</strong></p>
<p><strong>jvm：跨语言的平台</strong></p>
<ul>
<li>三种JVM<ul>
<li>Sun公司：Java HotShop</li>
<li>BEA ：JRockit</li>
<li>IBM：J9VM</li>
</ul>
</li>
</ul>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><ul>
<li>概念：就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上可分为系统虚拟机（如：VMware）和程序虚拟机（JVM）</li>
<li>java虚拟机是一台用于执行java字节码的虚拟计算机，它拥有独立的运行机制，其运行的java字节码也未必由java语言编译而成</li>
<li>java技术的核心就是java虚拟机</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>一次编译，多处运行</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ul>
<p><strong>JVM是运行在操作系统上的， 与硬件没有直接的交互</strong></p>
<p>JVM的整体结构：</p>
<p><img src="C:\Users\SFAG\AppData\Roaming\Typora\typora-user-images\image-20211128135252574.png" alt="image-20211128135252574"></p>
<p><img src="C:\Users\SFAG\AppData\Roaming\Typora\typora-user-images\image-20211128135653464.png" alt="image-20211128135653464"></p>
<p>java程序执行流程：</p>
<p><img src="C:\Users\SFAG\AppData\Roaming\Typora\typora-user-images\image-20211128140444203.png" alt="image-20211128140444203"> </p>
<h3 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h3><p>主要是在方法区和堆进行调优，java栈、本地方法栈和程序计数器中不会出现垃圾回收</p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul>
<li><p>JVM提供了ClassLoader</p>
<ul>
<li><strong>Bootstrap classLoader</strong>:主要负责加载核心的类库(java.lang.*等)，构造ExtClassLoader和APPClassLoader</li>
<li><strong>ExtClassLoader</strong>：主要负责加载jre&#x2F;lib&#x2F;ext目录下的一些扩展的jar</li>
<li><strong>AppClassLoader</strong>：主要负责加载应用程序的主函数类</li>
</ul>
</li>
<li><p>作用：加载class文件</p>
</li>
<li><p><strong>加载过程</strong></p>
<ul>
<li>类加载器收到类加载的请求（Application）</li>
<li>将这个请求向上委托给父类加载器去完成，一直向上委托了，直到启动类加载器（BOOT）</li>
<li>启动加载器检查是否能加载当前的这个类，能加载就结束，并使用当前类加载器，否则，抛出异常，通知子加载器进行加载</li>
<li>Class not found</li>
</ul>
</li>
<li><h6 id=""><a href="#" class="headerlink" title=""></a><img src="https://img-blog.csdnimg.cn/2020121722082798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGV5YW5iYW8=,size_16,color_FFFFFF,t_70" alt="img"></h6></li>
</ul>
<h3 id="双亲委派机制（类加载机制）"><a href="#双亲委派机制（类加载机制）" class="headerlink" title="双亲委派机制（类加载机制）"></a>双亲委派机制（类加载机制）</h3><p>​		当一个Hello.class这样的文件要被加载时。不考虑我们自定义类加载器，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的loadClass方法。父类中同理也会先检查自己是否已经加载过，如果没有再往上。注意这个类似递归的过程，直到到达Bootstrap classLoader之前，都是在检查是否加载过，并不会选择自己去加载。直到BootstrapClassLoader，已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出ClassNotFoundException</p>
<p>作用：为了安全，一定程度上防止的危险代码的植入，防止有人恶意篡改系统级别的类</p>
<p><img src="C:\Users\SFAG\AppData\Roaming\Typora\typora-user-images\image-20211128150615195.png" alt="image-20211128150615195"></p>
<p><strong>new一个对象所发生的一系列事情：</strong></p>
<ol>
<li>new student（）</li>
<li>类加载器加载<ul>
<li>加载：由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例</li>
<li>验证：验证是否符合class文件规范</li>
<li>准备：为类中的所有静态变量分配内存空间，并为其设置一个初始值（由于还没有产生对象，实例变量不在此操作范围内），被final修饰的static变量（常量），会直接赋值；</li>
<li>初始化：先父后子<ul>
<li>为静态变量赋值</li>
<li>执行static代码块（static代码块只有jvm能够调用）</li>
</ul>
</li>
</ul>
</li>
<li>创建对象<ul>
<li>在堆内分配对象所需要的内存</li>
<li>对所有实例变量赋默认值</li>
<li>执行实例初始化代码，先执行实例代码，然后执行构造方法，建立引用关系</li>
</ul>
</li>
</ol>
<h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p>组成沙箱的基本组件</p>
<ul>
<li><p>字节码校验器：确保java类文件遵循java语言规范。可以帮助java实现内存保护。但不是所有的类文件都会经过字节码校验，比如核心类</p>
</li>
<li><p>类加载器：在三个方面对沙箱起作用：</p>
<ul>
<li>防止恶意的代码去干涉善意的代码</li>
<li>守护了被信任的类库边界</li>
<li>将代码归入保护域，确定了代码可以进行那些操作</li>
</ul>
<p>虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每个被装载的类都将有一个名字，这个命名空间是由java虚拟机为每一个类加载器维护的，它们之间甚至不可见</p>
</li>
<li><p>存取控制器：存取控制器可以控制核心API对操作系统的存取权限，而这个控制策略的设定，可以由用户指定</p>
</li>
<li><p>安全管理器：是核心API和操作系统之间的主要接口，实现权限控制，比存取控制器优先级高</p>
</li>
<li><p>安全软件包：java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括：</p>
<ul>
<li>安全提供者</li>
<li>消息摘要</li>
<li>数字签名</li>
<li>加密</li>
<li>鉴别</li>
</ul>
</li>
</ul>
<h3 id="native关键字"><a href="#native关键字" class="headerlink" title="native关键字"></a>native关键字</h3><p>凡是带了native关键字的方法，说明Java的作用范围无法实现了，需要调用底层C语言的库，会进入本地方法栈（Native Method Strack），随后调用本地方法接口（Java Native Interface，简称：JNI）</p>
<ul>
<li>本地方法接口（Java Native Interface，简称：JNI）的作用：扩展java的使用，融合不同的编程语言为java所用</li>
<li>产生背景：java诞生之初，c语言和c++横行，所以想要立足，就必须能融合c和c++，最初JNI就用于扩展c和c++为java所用</li>
<li>在内存区域中，专门开辟了一块标记区域：本地方法栈（Native Method Strack），登记native关键字的方法，最终执行的时候，通过JNI加载本地方法库中的方法</li>
</ul>
<h3 id="PC寄存器（Program-Counter-Register）"><a href="#PC寄存器（Program-Counter-Register）" class="headerlink" title="PC寄存器（Program Counter Register）"></a>PC寄存器（Program Counter Register）</h3><p>又称程序计数器</p>
<p>每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用于存贮指向一条指令的地址，也就是将要执行的指令代码），在执行引擎读取下一条指令，是一个非常狭小的内存空间，几乎可以忽略不计</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>Method Area</p>
<p>​		是被所有线程共享的，所有字段和方法字节码，以及一些特殊方法，如构造函数、接口代码也在这里定义，简单说，所有定义的方法的信息都保存在该区域，属于共享空间；</p>
<p>​		静态方法、常量、类信息（构造方法、接口定义）、运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关</p>
<p>static、class、final、常量池</p>
<h3 id="JVM内存"><a href="#JVM内存" class="headerlink" title="JVM内存"></a>JVM内存</h3><p>运行时数据区Runable Date area</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是运行时的单位，</p>
<ul>
<li>程序&#x3D;算法+数据结构</li>
<li>栈：先进后出，后进先出</li>
<li>队列：先进先出（FIFO）</li>
<li>主管程序的运行、生命周期和线程同步，线程结束后，则栈内存也会释放，所以对于栈不存在垃圾回收</li>
<li>主要存储：8大基本类型、对象引用、实例的方法<ul>
<li>栈运行原理：栈帧，每个方法在执行时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程</li>
<li>局部变量表：存放了编译器可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型)和 returnAddress 类型(指向了一条字节码指令的地址)</li>
</ul>
</li>
<li>栈满：StackOverFlowErorr</li>
</ul>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Heap</p>
<p>堆是存储时的单位，主要存放对象实例和数组</p>
<p>内存划分：</p>
<p><img src="C:\Users\SFAG\AppData\Roaming\Typora\typora-user-images\image-20211129222840327.png" alt="image-20211129222840327"></p>
<p><img src="C:\Users\SFAG\AppData\Roaming\Typora\typora-user-images\image-20211202153633679.png" alt="image-20211202153633679"></p>
<ul>
<li><p>一个JVM只有一个堆内存，且堆内存是可以调节的</p>
</li>
<li><p>堆内存的用途：存放的是对象，垃圾收集器就是收集这些对象，然后根据GC算法回收</p>
</li>
<li><p>堆内存中划分</p>
<ul>
<li><p>年轻代</p>
<ul>
<li>新生区（Eden区）</li>
<li>幸存区（谁空谁是to）<ul>
<li>FromSpace </li>
<li>ToSpace</li>
</ul>
</li>
</ul>
</li>
<li><p>老年代</p>
<p>Java7及以前将堆空间逻辑上分成三部分：新生区+养老区+永久代</p>
</li>
</ul>
<p>　　Java8及以后将堆内存逻辑上分为：新生区+养老区+元空间（逻辑上存在，物理上不存在）</p>
</li>
<li><p>GC垃圾回收主要在新生区和养老区，假如内存满了，会报<strong>OOM错误</strong>（java.lang.OutOfMemory）</p>
</li>
<li><p>java1.8废除了永久代，替代的是<strong>元空间</strong>，元空间和永久代类似，都是方法区的实现，最大的区别是：<strong>元空间并不在JVM中</strong>，而是使用本地内存</p>
<ul>
<li>元空间有两个参数：<ul>
<li><strong>MetaspaceSize</strong> ：初始化元空间大小，控制发生GC阈值</li>
<li><strong>MaxMetaspaceSize</strong> ： 限制元空间大小上限，防止异常占用过多物理内存</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>移除永久代的原因</strong>：</p>
<ul>
<li>为融合HotSpot JVM与JRockit VM（新JVM技术）而做出的改变，因为JRockit没有永久代</li>
<li>有了元空间就不会出现永久代OOM问题（内存溢出）问题了</li>
</ul>
</li>
<li><p><strong>堆内存溢出（OOM）的原因</strong></p>
<p>在新生代中经过GC后还存活的对象会被复制到老年代中。当老年代空间不足时，JVM会对老年代进行完全的垃圾回收。如果GC后还是无法存放从幸存区（survivor区）复制过来的对象，就会出现OOM（OutOfMemory）</p>
<p><strong>解决方案：</strong></p>
<ul>
<li><p>先尝试将堆内存扩大，再次运行看结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms1024m -Xmx1024m -XX:+PrintGCDetail</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩大内存无法解决则需要分析内存占用情况，找问题原因</p>
<p>使用内存快照分析工具：Jprofiler、MAT</p>
<p>内存快照分析工具作用</p>
<ul>
<li>分析Dump内存文件，快速定位内存泄露</li>
<li>分析堆中的数据</li>
<li>获得大的对象</li>
</ul>
<p>使用方法：</p>
<ul>
<li><p>IDEA安装Jprofiler插件，重启IDEA</p>
</li>
<li><p>安装Jprofiler客户端工具，下载：<a target="_blank" rel="noopener" href="https://www.ej-technologies.com/download/jprofiler/files">https://www.ej-technologies.com/download/jprofiler/files</a></p>
</li>
<li><p>IDEA配置：</p>
<p><img src="C:\Users\SFAG\AppData\Roaming\Typora\typora-user-images\image-20211202163901504.png" alt="image-20211202163901504"></p>
</li>
<li><p>配置JVM参数：</p>
<p><img src="C:\Users\SFAG\AppData\Roaming\Typora\typora-user-images\image-20211202164010355.png" alt="image-20211202164010355"></p>
</li>
<li><p>程序代码：</p>
<p><img src="C:\Users\SFAG\AppData\Roaming\Typora\typora-user-images\image-20211202164041124.png" alt="image-20211202164041124"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>代码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BirthDate</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> m, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    day =d;</span><br><span class="line">    mouth=m;</span><br><span class="line">    year=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">BirthDate</span> <span class="variable">bir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BirthDate</span>(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure>

<p>代码中bir为对象引用，存在栈中；</p>
<p>对象new BirthDate（）存在堆中</p>
<p>d&#x3D;7,m&#x3D;8,y&#x3D;9为局部变量且数据类型为基本数据类型，所以变量和值都存储在栈中</p>
<p>day，mouth，year为BirthDate的成员变量，它们存储在堆中存储的new BirthDate（）对象中</p>
<h3 id="垃圾回收机制（GC）"><a href="#垃圾回收机制（GC）" class="headerlink" title="垃圾回收机制（GC）"></a>垃圾回收机制（GC）</h3><ul>
<li><p>垃圾回收作用范围：堆和方法区</p>
</li>
<li><p>垃圾回收的两种类型：轻GC（普通的GC）、重GC（全局的GC）</p>
</li>
<li><p><strong>垃圾</strong>：在堆中存在，但是不可能再被任何途径使用的对象</p>
<ul>
<li><p>垃圾判断算法</p>
<ul>
<li><strong>引用判断法</strong>：为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</li>
<li><strong>可达性分析法</strong>：以 <code>GC Roots</code> 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。</li>
</ul>
</li>
<li><p>GC root中包含的东西</p>
<ul>
<li>虚拟机栈空间中非静态变量表中引用的对象</li>
<li>本地方法栈中 <code>JNI</code> 中引用的对象</li>
<li>方法区中静态变量引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
</li>
<li><p>垃圾回收算法</p>
<ul>
<li><strong>复制算法</strong>：</li>
<li><strong>标记清除算法</strong>：扫描所有的对象，将需要存活的对象进行标记，然后清除没有标记的对象<ul>
<li>优点：不需要额外的空间</li>
<li>缺点：两次扫描会严重浪费时间，会产生内存碎片</li>
</ul>
</li>
<li><strong>标记压缩算法</strong>：防止产生内存碎片，再次扫描，向一端移动存活的对象，标记—清除—压缩</li>
</ul>
</li>
<li><p>常用的<strong>垃圾收集器</strong></p>
<ul>
<li><strong>serial</strong>：年轻代单线程串行垃圾收集器</li>
<li><strong>CMS</strong>：老年代多线程并行垃圾收集器</li>
</ul>
</li>
<li><p>垃圾回收器可以马上回收内存么？</p>
<ul>
<li><p>垃圾回收器不会马上释放内存空间，而是在某个对象被标记为垃圾之后的下一次GC时才会对内存空间进行释放。</p>
<p>我们可以手动执行<code>System.gc()</code>，通知虚拟机进行GC，但是Java语言规范并不保证GC一定会执行。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>总结：</p>
<ul>
<li><p>算法对比</p>
<ul>
<li>内存效率：复制算法&gt;标记清除算法&gt;标记压缩算法（时间复杂度）</li>
<li>内存整齐度：复制算法&#x3D;标记压缩算法&gt;标记清除算法</li>
<li>内存利用率：标记压缩算法&#x3D;标记清除算法&gt;复制算法</li>
</ul>
</li>
<li><p>没有最优的算法，只有最合适的算法</p>
<p>年轻代：</p>
<ul>
<li>存活率低</li>
<li>复制算法</li>
</ul>
<p>老年代</p>
<ul>
<li>区域大，存活率高</li>
<li>标记清除+标记压缩（多次标记清楚，一次压缩）</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/26/JVM%EF%BC%88java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%89/" data-id="cl4vd9h1t0001ssgvcj47dk0l" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/06/26/java%E4%B8%AD%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2022/06/26/easyBI%E7%9A%84%E4%BD%BF%E7%94%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/26/RabbitMQ%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/26/redis/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/26/ody-db/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/26/Nginx/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/26/PMO%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>